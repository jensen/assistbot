input AddMessageInput {
  twitchId: ID!
  message: String
  emotes: String
}

type AddMessagePayload {
  message: MessageEdge
}

input AddRequestInput {
  twitchId: ID!
  type: String
  description: String
  link: String
}

type AddRequestPayload {
  request: RequestEdge
}

type Chat {
  groups(first: Int, after: String, last: Int, before: String): MessageGroupConnection
  messages(first: Int, after: String, last: Int, before: String): MessageConnection
}

type Message implements Node {
  id: ID!
  message: String
  emotes: String
  createdAt: String
  user: User
}

type MessageConnection {
  edges: [MessageEdge]
  pageInfo: PageInfo
}

type MessageEdge {
  cursor: String!
  node: Message
}

type MessageGroup implements Node {
  id: ID!
  user: User
  messages: [Message]
}

type MessageGroupConnection {
  edges: [MessageGroupEdge]
  pageInfo: PageInfo
}

type MessageGroupEdge {
  cursor: String!
  node: MessageGroup
}

type Mutation {
  _empty: String
  addUser(twitchId: String!): User
  addRequest(input: AddRequestInput!): AddRequestPayload
  acceptRequest(id: ID!): Request
  completeRequest(id: ID!): Request
  addMessage(input: AddMessageInput!): AddMessagePayload
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  node(id: ID!): Node
  users: [User]
  user(id: ID!): User
  queue: Queue
  current: Queue
  chat: Chat
  requests(from: Int): [Request]
  request(id: ID, filter: String): Request
  messages(from: Int): [Message]
  message(id: ID!): Message
}

type Queue implements Node {
  id: ID!
  requests(first: Int, after: String, last: Int, before: String, status: String): RequestConnection
}

type Request implements Node {
  id: ID!
  description: String
  type: String
  link: String
  createdAt: String
  updatedAt: String
  acceptedAt: String
  completedAt: String
  user: User
  messages: [Message]
}

type RequestConnection {
  edges: [RequestEdge]
  pageInfo: PageInfo
}

type RequestEdge {
  cursor: String!
  node: Request
}

type Subscription {
  _empty: String
  addRequest: RequestEdge
  addMessage: MessageEdge
}

input UpdateRequestInput {
  id: ID!
}

type UpdateRequestPayload {
  request: Request
}

type User implements Node {
  id: ID!
  username: String
  displayName: String
  avatar: String
  twitchId: String
  requests(first: Int, after: String, last: Int, before: String): RequestConnection
  messages(first: Int, after: String, last: Int, before: String): MessageConnection
}

